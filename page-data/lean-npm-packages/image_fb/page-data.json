{"componentChunkName":"component---src-templates-blog-post-share-image-js","path":"/lean-npm-packages/image_fb","result":{"data":{"site":{"siteMetadata":{"title":"Luciano Mammino \"Loige\" - Cloud developer, entrepreneur, fighter, butterfly maker!","author":"Luciano Mammino","siteUrl":"https://loige.co","twitterProfile":"loige","disqusShortName":"loige"}},"markdownRemark":{"id":"6a769200-3e31-5bb1-b3e9-41a7170839f4","timeToRead":11,"headings":[{"value":"Repository vs Registry","depth":2},{"value":"Publishing on NPM","depth":2},{"value":"Default rules","depth":2},{"value":".gitignore & .npmignore","depth":2},{"value":"The files field","depth":2},{"value":".npmignore vs the files field","depth":2},{"value":"An example","depth":2},{"value":"Testing the package files","depth":2},{"value":"Conclusion","depth":2}],"html":"<p>Every developer on the planet knows how modular Node.js and the JavaScript ecosystem have become.\nThis is probably due to the great job that package management systems and registries like <a href=\"https://bower.io/\">bower</a> (discontinued) and <a href=\"https://npm.com\">npm</a> carried over in the last few years. I personally believe that this is also a consequence of the ‚Äúmany small modules‚Äù philosophy that has been popularised within the JavaScript ecosystem.</p>\n<p>This is great, but all that glitters is not gold‚Ä¶ Look, for instance, at this picture for a second:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAAOABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQG/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAe1WNFlY4f/EABwQAAMAAQUAAAAAAAAAAAAAAAECAwASEyEiM//aAAgBAQABBQJp5tjXIdHnUsF5n5//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8BxH//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8B1X//xAAbEAACAwADAAAAAAAAAAAAAAAAAQIRIRASMf/aAAgBAQAGPwKTttnXfOLU8Lb2hH//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhQbExYf/aAAgBAQABPyF02QFyrNRu5gh+rEdPQuowbuDydnZ//9oADAMBAAIAAwAAABCzD//EABYRAQEBAAAAAAAAAAAAAAAAAAEAMf/aAAgBAwEBPxBFgv/EABcRAAMBAAAAAAAAAAAAAAAAAAABETH/2gAIAQIBAT8QUGmf/8QAHxABAAEEAQUAAAAAAAAAAAAAAREAITGhUUFhscHh/9oACAEBAAE/EAKsYYUwPOqLq3SZMhTleUOOY9UVtOqj2sbpZRJwAbz8rc8lf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/a514505fd96508a4e32bda24ddc40363/8d3d1/node_modules_heaviest_objects_in_the_universe.webp 256w,\n/static/a514505fd96508a4e32bda24ddc40363/354cf/node_modules_heaviest_objects_in_the_universe.webp 512w,\n/static/a514505fd96508a4e32bda24ddc40363/47a22/node_modules_heaviest_objects_in_the_universe.webp 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/a514505fd96508a4e32bda24ddc40363/b95e4/node_modules_heaviest_objects_in_the_universe.jpg 256w,\n/static/a514505fd96508a4e32bda24ddc40363/1779b/node_modules_heaviest_objects_in_the_universe.jpg 512w,\n/static/a514505fd96508a4e32bda24ddc40363/5fd6b/node_modules_heaviest_objects_in_the_universe.jpg 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/jpeg\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/a514505fd96508a4e32bda24ddc40363/5fd6b/node_modules_heaviest_objects_in_the_universe.jpg\"\n          alt=\"node_modules heaviest objects in the universe\"\n          title=\"node_modules heaviest objects in the universe\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n    </span></p>\n<p>Yeah you have probably seen this picture before and it‚Äôs probably not funny anymore‚Ä¶ Anyway, this picture is a good summary right there on how this ‚Äúmany small modules‚Äù idea got a little bit out of hand within the JavaScript ecosystem.</p>\n<p>Every time you run <code>npm install</code> you basically start to get so many files that you might feel like you are downloading the entire world wide  into your hard drive! üò∞</p>\n<p>There are even tools that try to scout for <code>node_modules</code> folders in your system and get rid of them (E.g. <a href=\"https://www.npmjs.com/package/wipe-modules\"><code>wipe-modules</code></a>). There are also some developers who showed how all the <code>node_modules</code> folders in their system is making their backups too slow (<a href=\"https://t.co/2KirOXF2v2\">see tweet</a>)!</p>\n<p>Some like to make fun of this issue or they just complain about it. In this article, I don‚Äôt want to do any of those things. I‚Äôd rather prefer to be a little bit more constructive and try to share some simple techniques to keep your NPM modules as lean as possible, so that other developers will save bandwidth and time when pulling your modules from NPM!</p>\n<h2 id=\"repository-vs-registry\" style=\"position:relative;\"><a href=\"#repository-vs-registry\" aria-label=\"repository vs registry permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Repository vs Registry</h2>\n<p>In some languages like Go or PHP, what you have in a module repository is exactly what you get through the package manager when trying to install the module. This is because the code you download through the package manager is actually coming straight from the repository (or from a proxy that keeps a copy of the repository). In this cases, the structure of your repository is fundamentally tied to the file structure of your module: what you get by installing a module is pretty much what you would get by cloning the repository.</p>\n<p>NPM doesn‚Äôt work this way. In fact, NPM allows you to selectively push files into the registry, so you might end up with a very different file structure compared to what you have in your git repository.</p>\n<p>While this interesting property of the system have caused some security issues in the past (see the <a href=\"https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/\">event-stream module incident</a> if you are curious), it also offers us an opportunity to be very selective with what we publish and keep the module lean.</p>\n<p>This is especially important if you ‚Äúbuild‚Äù your JavaScript code (e.g. using Typescript, Babel or a module bundler), so that the ‚Äúdistribution‚Äù (<em>dist</em>) version of your module is the result of a compilation/transpilation/bundling process. In such cases, you don‚Äôt need to publish the entire codebase on NPM as your users will be using only the <em>dist</em> version of your code. The same goes for tests, documentation, images and other files that won‚Äôt be used by the users of your module in their codebase, you should keep them only in your repository and avoid to publish them in the registry.</p>\n<p>Conversely, you probably don‚Äôt want to keep <em>dist</em> code in your repository. This code can easily be regenerated by the build toolchain when necessary and there‚Äôs no point in tracking changes on the <em>dist</em> files when what you are really changing over time is the source code. In git you can use <code>.gitignore</code> to make sure <em>dist</em> files are kept out of the repository.</p>\n<p>In short, registries are for production-ready code (<em>dist</em>) while repositories are for development code (<em>src</em>).</p>\n<p>In the rest of this article we will see some ways to configure an NPM package so that all the unnecessary files will be excluded from the registry.</p>\n<h2 id=\"publishing-on-npm\" style=\"position:relative;\"><a href=\"#publishing-on-npm\" aria-label=\"publishing on npm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Publishing on NPM</h2>\n<p>With the NPM command line, <a href=\"https://docs.npmjs.com/cli/publish\"><code>npm publish</code></a> is the de facto way of publishing new modules (or new versions of a module) into the NPM registry.</p>\n<p>An NPM module is nothing else than a folder with a valid <code>package.json</code> file in it. It doesn‚Äôt have to be a git repository (in reality the definition of what an NPM module can be is a little bit more complicated, to get the full spiel, check out <a href=\"https://docs.npmjs.com/misc/developers#what-is-a-package\">the official NPM documentation</a>).</p>\n<p>By default <code>npm publish</code> will publish all the files in the package directory (including subfolders recursively).</p>\n<p>So the first thing to do is to be careful and make sure that you don‚Äôt have sensible files containing passwords, tokens or other sensible information in your project folder. It‚Äôs generally a good idea to keep those away from the module folder, just in case‚Ä¶</p>\n<p>You should also try to avoid to keep unrelated files in the same folder. Yeah, I admit that many times I did some quick n‚Äôdirty <code>wget</code> to get something I needed while I was working on a module and ended up with a lot of unrelated stuff published in my module. Please be smarter than me, don‚Äôt do that! üòú</p>\n<h2 id=\"default-rules\" style=\"position:relative;\"><a href=\"#default-rules\" aria-label=\"default rules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Default rules</h2>\n<p>Before starting to deep dive into the different ways you can specify the files to be included/excluded when you publish your package, let‚Äôs see first what are the default rules.</p>\n<p>No matter what you do, there are some files that are <strong>always excluded</strong>:</p>\n<ul>\n<li><code>.*.swp</code></li>\n<li><code>._*</code></li>\n<li><code>.DS_Store</code></li>\n<li><code>.git</code></li>\n<li><code>.hg</code></li>\n<li><code>.npmrc</code></li>\n<li><code>.lock-wscript</code></li>\n<li><code>.svn</code></li>\n<li><code>.wafpickle-*</code></li>\n<li><code>config.gypi</code></li>\n<li><code>CVS</code></li>\n<li><code>npm-debug.log</code></li>\n</ul>\n<p>Similarly, there are files that are <strong>always included</strong>:</p>\n<ul>\n<li><code>package.json</code></li>\n<li><code>README.md</code> (and its variants, like <code>README.markdown</code> or <code>README.rst</code>)</li>\n<li><code>CHANGELOG.md</code> (and its variants, like <code>CHANGELOG.markdown</code> or <code>CHANGELOG.rst</code>)</li>\n<li><code>LICENSE</code> and <code>LICENCE</code></li>\n</ul>\n<p>Note that <code>package-lock.json</code> is NOT automatically included.</p>\n<h2 id=\"gitignore--npmignore\" style=\"position:relative;\"><a href=\"#gitignore--npmignore\" aria-label=\"gitignore  npmignore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>.gitignore</code> &#x26; <code>.npmignore</code></h2>\n<p>The first interesting property of <code>npm publish</code> is that, if your folder is also a git repository and you are using a <code>.gitignore</code> file, all the patterns listed in it will be used to exclude files.</p>\n<p>So, for instance, if you have <code>*.cache</code> pattern in your <code>.gitignore</code>, all the files matching the pattern won‚Äôt be published in the registry.</p>\n<p>We discussed already that you might want to have different rules between what you track in your repository and what you publish to the registry, so relying on one configuration to ignore files for both targets might not always be a good idea.</p>\n<p>In those cases you can create a more specific file called <code>.npmignore</code> (which supports exactly the same syntax as <code>.gitignore</code>). If this file exists, <code>npm publish</code> will use that to exclude files, rather than using <code>.gitignore</code>.</p>\n<p>This means that there‚Äôs no inheritance, the two files are totally independent. If you want a pattern to exclude files for both your repository and your registry, you will have to put the pattern in both configuration files.</p>\n<p>One interesting lesser known (and rarely used) tip is that you can put <code>.npmignore</code> files also in subdirectories. The patterns specified in these files will apply only to the subtree of directories where the <code>.npmignore</code> is found.</p>\n<h2 id=\"the-files-field\" style=\"position:relative;\"><a href=\"#the-files-field\" aria-label=\"the files field permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The <code>files</code> field</h2>\n<p>If you don‚Äôt like the idea of blacklisting some files (in fairness, you might forget to exclude a file with some sensitive information in it‚Ä¶) you can also follow a <em>whitelisting approach</em>.</p>\n<p>In fact, NPM allows you to use a field called <code>files</code> in your <code>package.json</code> to specify an array of file patterns to include in the package.</p>\n<p>From the <a href=\"https://docs.npmjs.com/files/package.json#files\">official documentation</a>:</p>\n<blockquote>\n<p>The optional <code>files</code> field is an array of file patterns that describes the entries to be included when your package is installed as a dependency. File patterns follow a similar syntax to <code>.gitignore</code>, but reversed: including a file, directory, or glob pattern (<code>*</code>, <code>**/*</code>, and such) will make it so that file is included in the tarball when it‚Äôs packed. Omitting the field will make it default to [<code>\"*\"</code>], which means it will include all files.</p>\n</blockquote>\n<p>One important rule is that files included with the <code>files</code> field cannot be excluded through <code>.npmignore</code>. In other words, the <code>files</code> field has higher priority than <code>.npmignore</code>.</p>\n<h2 id=\"npmignore-vs-the-files-field\" style=\"position:relative;\"><a href=\"#npmignore-vs-the-files-field\" aria-label=\"npmignore vs the files field permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>.npmignore</code> vs the <code>files</code> field</h2>\n<p>As we said, <code>.npmignore</code> is effectively a blacklist of files, while the <code>files</code> field acts as a whitelist.</p>\n<p>This means that, if the <code>files</code> field is populated, everything is excluded by default and only those files explicitly listed will be included in the packaged tarball.</p>\n<p>You are probably wondering now, should I use the <code>files</code> field or the <code>.npmignore</code> file?</p>\n<p>To be honest, I don‚Äôt think there‚Äôs a silver bullet here. Just pick the mental model (whitelist vs blacklist) that comes easier to you.</p>\n<h2 id=\"an-example\" style=\"position:relative;\"><a href=\"#an-example\" aria-label=\"an example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An example</h2>\n<p>I generally prefer to keep my folder structure simple and explicit by having folders for source (<code>src</code>) and distribution files (<code>dist</code>).</p>\n<p>With this approach you can simply say that <code>src</code> is what you want to keep in your repo (excluding <code>dist</code>) and, viceversa, in <code>dist</code> is what you want to publish on NPM (excluding <code>src</code>).</p>\n<p>Just to make a very simple example, let‚Äôs say we are building a new library and our code base contains the following files:</p>\n<ul>\n<li><code>src/index.js</code>: source code for our module logic (using ES2019 syntax, because we like to be cool! üòé)</li>\n<li><code>src/index.test.js</code>: unit test file</li>\n<li><code>dist/index.js</code>: distributable version of our module (<em>transpiled</em> to ES5 with babel)</li>\n</ul>\n<p>Now we want to keep <code>src/index.js</code> and <code>src/index.test.js</code> in our repository (but not in your final package) and <code>dist/index.js</code> in our package (but not in our repository).</p>\n<p>One way we can achieve this result is by adding <code>dist/</code> to our <code>.gitignore</code>, this will make sure we never commit files from the dist folder to the repository.\nThen we can either use the <code>.npmignore</code> file or the <code>files</code> field to specify what goes in our package.</p>\n<p>I personally prefer to use the <code>files</code> field, which in this case will be super simple.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"some-test-package\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"main\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dist/index.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"dist/\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that I am also pointing the entrypoint (<code>main</code>) to our <code>index.js</code> file in <code>dist</code>. This is what will be used when our module is imported.</p>\n<p>With this approach I can add all sorts of other files to my repo (e.g. integration tests, functional tests, images, documentation, etc.) and I won‚Äôt have to worry about polluting my final package and making the end user download a lot of stuff that they won‚Äôt need!</p>\n<h2 id=\"testing-the-package-files\" style=\"position:relative;\"><a href=\"#testing-the-package-files\" aria-label=\"testing the package files permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Testing the package files</h2>\n<p>But how do we know if our setup is correct? We don‚Äôt want to publish the package just to see if our setup is correct.</p>\n<p>Thankfully there are at least 2 ways to preview what‚Äôs gonna end up in the registry with <code>npm publish</code> without having to actually publish anything.</p>\n<p>The first way is <code>npm pack</code>, this command will create a tarball that contains all the files that will be published in the registry.</p>\n<p>The output is actually pretty nice and it will list all the included files.</p>\n<p>If we run <code>npm pack</code> on the package folder from the example above we should see something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">npm notice\nnpm notice üì¶  some-test-package@1.0.0\nnpm notice === Tarball Contents ===\nnpm notice 74B  dist/index.js\nnpm notice 266B package.json\nnpm notice 13B  LICENSE.md\nnpm notice 39B  README.md\nnpm notice === Tarball Details ===\nnpm notice name:          some-test-package\nnpm notice version:       1.0.0\nnpm notice filename:      some-test-package-1.0.0.tgz\nnpm notice package size:  428 B\nnpm notice unpacked size: 392 B\nnpm notice shasum:        738776acad3cb41c549a884c6f9e946e7f367657\nnpm notice integrity:     sha512-QQS68QqFtfTGE[...]XmPGJpSYqmpKw==\nnpm notice total files:   4\nnpm notice\nsome-test-package-1.0.0.tgz</code></pre></div>\n<p>Note that only 4 files have been included:</p>\n<ul>\n<li><code>dist/index.js</code></li>\n<li><code>package.json</code></li>\n<li><code>LICENSE.md</code></li>\n<li><code>README.md</code></li>\n</ul>\n<p>An alternative approach is to run <code>npm publish</code> in <em>dry run</em> mode with the flag <code>--dry-run</code>. With this approach no tarball is created but you will see the output of all the files that would be published with a normal <code>npm publish</code> run.</p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>In summary, these are the main points I wanted to get across with this article:</p>\n<ul>\n<li>What you have in your repository can (and probably should) be different from what you publish in the NPM registry.</li>\n<li>You can exclude files by specifying patterns in <code>.npmignore</code> (similarly to <code>.gitignore</code>)</li>\n<li>Alternatively, you can whitelist files by specifying patterns of files to be included in the <code>files</code> field in your <code>package.json</code></li>\n<li>There‚Äôs a list of files that are always included and, similarly, a list of files that are always excluded (see <a href=\"#default-rules\">list above</a>).</li>\n<li>Be smart and only publish the bare minimum needed for people to use your library: keep your NPM package lean!</li>\n</ul>\n<p>With these advices we are probably not going to solve the <code>node_modules</code> drama, but at least we can do our part to make it a little bit more bearable.</p>\n<p>Please, let me know what you think about these advices here in the comments. Did you know about these configuration options? Did you use other strategies to keep your NPM packages lean?</p>\n<p>I‚Äôll see you in the next article. Until then, keep your NPM modules lean! ü§óüì¶</p>\n<p>CIAO üëã</p>","frontmatter":{"title":"Lean NPM packages","slug":"lean-npm-packages","author":"Luciano Mammino","tags":["javascript","node-js","npm"],"date":"September 08, 2019","header_img":{"publicURL":"/static/2c6b16403f5bc00909676e8ddf0cb9e8/lean-npm-packages.jpg"}}}},"pageContext":{"slug":"lean-npm-packages","width":1200,"height":630,"type":"facebook"}},"staticQueryHashes":[]}